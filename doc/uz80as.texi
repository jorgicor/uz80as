\input texinfo

@c ==========================================================================
@c uz80as, an assembler for the Zilog Z80 and several other microprocessors.
@c ==========================================================================

@c %**start of header
@setfilename uz80as.info

@c To get @value{VERSION}.
@include version.texi

@c To get the copyright years @value{COPYRIGHT_YEARS}
@include copyright.texi

@settitle uz80as (Micro Z80 assembler) @value{VERSION}
@c %**end of header

@dircategory Software development
@direntry
* uz80as: (uz80as).	Micro Z80 assembler.
@end direntry

@copying
This manual is for uz80as (Micro Z80 assembler) version @value{VERSION}
(updated @value{UPDATED}).

Copyright @copyright{} @value{COPYRIGHT_YEARS} Jorge Giner Cordero

@quotation
Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
@end quotation
@end copying

@titlepage
@title uz80as
@subtitle Micro Z80 assembler
@subtitle version @value{VERSION}, updated @value{UPDATED}
@author Jorge Giner Cordero
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top Micro Z80 assembler

This manual is for @command{uz80as} (Micro Z80 assembler) version
@value{VERSION} (updated @value{UPDATED}).
@end ifnottex

@menu
* About::		About @command{uz80as}.
* Source syntax::	Source format accepted by @command{uz80as}.
* Reference::		@command{uz80as} reference manual.
* Targets::		Targets and instruction sets supported.
* Source guide::	How the program works.
* Copyright::		Copyright and license.
@end menu

@node About
@chapter About

@command{uz80as} is an assembler for the Zilog Z80 and several other microprocessors.
It accepts source files with the same syntax accepted by the Telemark Cross Assembler (TASM), with only minor differences.

Currently, uz80as can assemble for these microprocessors:
@itemize @bullet
@item Z80 family
@itemize @bullet
@item Zilog Z80
@item Hitachi HD64180
@item Sharp LR35902 (Nintendo Gameboy CPU)
@end itemize
@item 6500 family
@itemize @bullet
@item MOS Technology 6502
@item California Micro Devices G65SC02
@item Rockwell R6501, Rockwell R65C02, R65C29
@item Western Design Center W65C02S
@end itemize
@item Datapoint 2200 (versions I & II)
@item Intel 4004, 4040, 8008, 8021, 8022, 8041, 8048, 8051, 8080, 8085
@item Motorola 6800, 6801, 68HC11
@item RCA 1802
@end itemize

@command{uz80as} is free software.

The latest version of the program, source code and documentation can be found at @uref{https://jorgicor.niobe.org/uz80as}.

For bug reports and suggestions, you can write to Jorge Giner at @email{jorge.giner@@hotmail.com} .

@node Source syntax
@chapter Source syntax

Each line of the source file must be a an assembler statement or a preprocessor directive.
Mathematical expressions can be used where a number is expected.

@menu
* Statements::			Format of a statement.
* Expressions::			Expression format.
* Assembler directives::	To control the assembler process.
* Preprocessor directives::	How the preprocessor works.
@end menu

@node Statements
@section Statements

Each assembler statement must follow this format:

@example
label operation operands comment
@end example

For example:

@example
START	LD	A,5	; Load 5 into A
@end example

Everything that starts with an alphabetic character at the first column is considered a label.

A label must be separated by the rest of fields on the line by a space, tab or a colon @samp{:}.

The operation can be a microprocessor instruction or an assembler directive (assembler directives start with a dot @samp{.}).

Assembler directives can start at column 1, as they start with a dot @samp{.} and cannot be taken for a label.
But a microprocessor instruction cannot start at column 1, or it would be taken as a label.

The operation must be separated by the operands (if any) with a space.

The rest of the line is the operands field until we reach the end of line or a semicolon @samp{;}.

If we find a semicolon @samp{;} character at any position, the rest of the line is ignored.

All of these fields are optional except the operands field which, if present, must be preceded always by an operation field.

These are examples of statements:

@example
; Program version 3
        .ORG 4000
LABEL   LD A,5
        ADD 6          ; Add 6
MEM     .FILL 2
.END    ; End of program
@end example

A backslash character @samp{\} can be used to simulate a new line.
Then it is possible to put one or more statements on the same line:

@example
	LD A,B\ LD B,C\ LD C,A
@end example

Remember that, as the backslash character simulates a new line, if the first character after it is alphabetic, it will be considered as a label.
That is why we leave a space after the backslash in the example above.

@menu
* Label field::			Format of the label field.
* Operation field::		Format of the operation field.
* Operands field::		Format of the operand field.
* Comment field::		Format of the comment field.
@end menu

@node Label field
@subsection Label field

The label field must start with an character from @samp{A} to @samp{Z}.
The next characters, if any, must be letters, numbers, underscores @samp{_} or periods @samp{.}.
Any other character terminates the label, and it must be a space, a tab or a colon @samp{:}.

A label with more than 31 characters will issue an error.

Labels are case sensitive, so @samp{START} is different from @samp{start}.

Each label has a value, which is:

@itemize @minus
@item
If an @code{.EQU} directive follows the label, the label takes the value of the expression introduced by the @code{.EQU}.
@item
If an @code{.ORG} directive follows the label, the label takes the address that the @code{.ORG} directive is setting.
@item
Otherwise, the value of the label is the current program counter.
@end itemize

@node Operation field
@subsection Operation field

The operation field is a microprocessor instruction opcode (like @code{ADD}, @code{SUB}, @code{CALL}, etc) or an assembler directive (like @code{.ORG}, @code{.EQU}, etc).
If it is a microprocessor instruction, it cannot start at the first column of the line, because in that case it would be considered a label.
Assembler directives can start at any column as they start with a dot @samp{.}.

@node Operands field
@subsection Operands field

The operands field contains the operands for the instruction or the arguments of assembler directives. They can involve expressions, addressing modes, etc.

@node Comment field
@subsection Comment field

A comment starts with a semicolon @samp{;} character and extends to the end of the line.
It can be the only field on a line.

@node Expressions
@section Expressions

Wherever a number is accepted in the operands of an instruction or directive, you can use an expression instead.
An expression is formed using labels, constants, the program counter symbol, operators and parenthesis.

@menu
* Numeric constants::		Syntax of a number.
* Character constants::		Syntax of a character.
* String constants::		Syntax of a character string.
* Program counter::		Specifying the current address.
* Operators::			Operators to build expressions.
@end menu

@node Numeric constants
@subsection Numeric constants

A decimal numeric constant is expressed normally by the decimal number, optionally followed by the @samp{D} suffix.

An hexadecimal constant is expressed by using the @samp{$} prefix or by using the @samp{H} suffix.
It can be formed by the digits from @samp{0} to @samp{9} and the letters from @samp{A} to @samp{F}.
Note that an hexadecimal constant that uses the suffix form and starts with a letter must be prefixed with a @samp{0} digit or it will be taken as a label.

An octal constant is expressed by using the @samp{@@} prefix or by using the @samp{O} suffix.
It can be formed by the digits from @samp{0} to @samp{7}.

Binary constants are expressed using the @samp{%} prefix or by using the @samp{B} suffix.

All the letters for hexadecimal constants or suffixes can be in lower case as well.

For example, all these values represent the decimal number 255, using different notations:

@example
Decimal         255 or 255D
Hexadecimal     $FF or 0FFH
Octal           @@377 or 377O
Binary          %11111111 or 11111111B
@end example

@node Character constants
@subsection Character constants

Character constants are single characters enclosed in single quotes, for example: 'c'.
The ASCII code of the character is used as the value.
Non-printable characters cannot be expressed this way, but you can use the @code{.TEXT} directive instead.

@node String constants
@subsection String constants

String constants are one or more characters enclosed in double quotes, for example: "This is a string." .
String constants are not allowed in expressions but can be used with certain directives, like @code{.TITLE}, @code{.TEXT}, @code{.BYTE}, @code{.DB}, @code{.WORD} and @code{.DW}.
String constants can contain escape sequences to represent non-printable characters.
An escape sequence starts with the backslash @samp{\} character:

@table @code
@item \n
Line feed.
@item \r
Carriage return.
@item \b
Backspace.
@item \t
Tab.
@item \f
Form feed.
@item \\
Backslash.
@item \"
Double quote.
@end table

You can express any other character by using the backslash @samp{\} followed by an octal constant using exactly 3 digits.
For example, @code{\377} represents the character value 255, and is the maximum octal value representable using a backslash.

Examples:

@example
"This ends with a newline.\n"
"\tThe name is \"Bye Bug\"."
@end example

@node Program counter
@subsection Program counter

In an expression you can use the value of the current program counter which is the memory address that will be assigned to the line we are assembling.
You can use the dollar character @samp{$} or the asterisk @samp{*} to represent the current program counter.

For example:

@example
START  LD HL,START
@end example

is equivalent to

@example
START  LD HL,$
@end example

@node Operators
@subsection Operators

All operations are done using at least 32 bit signed precision.
An expression is evaluated left to right and there is no operator precedence.
Use parenthesis if you want to change the precedence.
For example:

@example
1 + 2*3 + 4
@end example

will be evaluated as:

@example
((1 + 2) * 3) + 4
@end example

Use parenthesis to indicate the desired order of evaluation:

@example
1 + (2*3) + 4
@end example

Summary of operators:

@table @code
@item +
Addition.
@item -
Subtraction or negation.
@item *
Multiplication.
@item /
Integer division.
@item %
Modulo.
@item <<
Logical left shift.
@item >>
Arithmetic right shift (the sign bit fills new positions).
@item ~
One's complement (invert all bits).
@item = or ==
Equal. The result is 1 if equal, 0 if not.
@item !=
Not equal. The result is 1 if not equal, 0 if equal.
@item <
Less than. The result is 1 if a < b, 0 otherwise.
@item <=
Less than or equal. The result is 1 if a <= b, 0 otherwise.
@item <
Greater than. The result is 1 if a > b, 0 otherwise.
@item <=
Greater than or equal. The result is 1 if a >= b, 0 otherwise.
@item &
Binary @samp{AND}.
@item |
Binary @samp{OR}.
@item ^
Binary @samp{XOR}.
@end table

For the shift operators @code{>>} and @code{<<}, the second operand specifies the number of bits to shift the first operand.

@node Assembler directives
@section Assembler directives

The assembler directives are distinguished from the microprocessor instructions because they begin with a dot character @samp{.}.
They are commands to control the assembly process.

@menu
* BLOCK::	.BLOCK directive.
* BYTE::	.BYTE directive.
* CHK::		.CHK directive.
* CODES::	.CODES directive.
* DB::		.DB directive.
* DS::		.DS directive.
* DW::		.DW directive.
* ECHO::	.ECHO directive.
* EJECT::	.EJECT directive.
* END::		.END directive.
* EQU::		.EQU directive.
* EXPORT::	.EXPORT directive.
* FILL::	.FILL directive.
* LIST::	.LIST directive.
* LSFIRST::	.LSFIRST directive.
* MSFIRST::	.MSFIRST directive.
* NOCODES::	.NOCODES directive.
* NOLIST::	.NOLIST directive.
* NOPAGE::	.NOPAGE directive.
* ORG::		.ORG directive.
* PAGE::	.PAGE directive.
* TEXT::	.TEXT directive.
* TITLE::	.TITLE directive.
* WORD::	.WORD directive.
@end menu

@node BLOCK
@subsection BLOCK

@example
[label] .BLOCK expr
@end example

@code{expr} is evaluated and its value added to the current program counter.
Thus @code{.BLOCK n} is equivalent to @code{.ORG $+n}.

@node BYTE
@subsection BYTE

@example
[label] .BYTE expr [, expr ...]
@end example

The @code{.BYTE} directive is supplied with one or more expressions separated
by commas.
Each @code{expr} can be a numeric expression or a string constant.
If the expression is numeric, the lower eight bits of the result are output to the object file.
If the expression is a string, for each character its @samp{ASCII} value is output to the object file.

@example
START .BYTE 'a', "hello", 5 - START
@end example

Note that the program counter symbol used in any of the expressions refers to the value the program counter had at the beginning of the line, and not at the start of each expression.

You can use @code{.DB} as an alternative name for @code{.BYTE}.

@node CHK
@subsection CHK

@example
[label] .CHK expr
@end example

The checksum directive takes all the bytes from the address @code{expr} up to the current address, and combines them using an exclusive OR operation (XOR).
The result (a byte) is output to the object file.
The address defined by @code{expr} must be in the range @code{[0, current program counter[}.

For example, this will output in the object file the bytes 1, 2, 3, 4 and the result of CHK, which is 4:

@example
START   .DB 1, 2, 3, 4
        .CHK START
@end example

@node CODES
@subsection CODES

Enables the generation of line numbers, opcodes, etc. in the listing file.
This is enabled by default, but can be disabled using the @code{.NOCODES} directive.

@node DB
@subsection DB

@code{.DB} is an alternate name for @code{.BYTE}.

@node DS
@subsection DS

@code{.DS} is an alternate name for @code{.BLOCK}.

@node DW
@subsection DW

@code{.DW} is an alternate name for @code{.WORD}.

@node ECHO
@subsection ECHO

@example
[label] .ECHO expr
[label] .ECHO string
@end example

Outputs to the console (stderr) an expression value or a string.

For example,

@example
.ECHO "The code size is "
.ECHO PRG_END - PRG_START
.ECHO " bytes long.\n"
@end example

may result in:

@example
The program size is 237 bytes long.
@end example

@node EJECT
@subsection EJECT

The @code{.EJECT} directive is accepted but not implemented.
In @code{TASM}, forces a new page in the listing file.

@node END
@subsection END

@example
[label]	.END [addr]
@end example

The @code{.END} directive should be the last one in the program.
It is accepted only for compatibility with @command{TASM} but, if not used, we will only issue a warning.
If it is present, it is an error to use any directive or instruction that generates code after it.
It is an error to have more than one @code{.END} directive.

@node EQU
@subsection EQU

@example
label .EQU expr
@end example

Normally, a label takes the value of the current program counter, but you can assign the result of an expression to a label.
The label is mandatory in this case.

An alternative syntax uses the equal sign @samp{=} instead of @code{.EQU}:

@example
label = 25
@end example

@node EXPORT
@subsection EXPORT

@example
[label] .EXPORT label [, label...]
@end example

With the @code{.EXPORT} directive you can specify a list of labels that will be exported to a symbol export file.
The symbol export file will contain the labels and their values as equates.
For example:

@example
	.EXPORT start, func1
@end example

could produce in the symbol export file this equates:

@example
start	.EQU  $4000
func1	.EQU  $4008
@end example

@node FILL
@subsection FILL

@example
[label] .FILL number_of_bytes [, fill_value]
@end example

Outputs @code{number_of_bytes} bytes to the output file.
The value output to each byte is the least significant byte of @code{fill_value}.
If no @code{fill_value} is supplied, the value 255 is used.
It is an error to supply a negative @code{number_of_bytes}.

@c TODO: by default the memory is filled with 0 at start.

@node LIST
@subsection LIST

Turns on the output to the listing file.
This is the default.
Use @code{.NOLIST} to disable it.

@node LSFIRST
@subsection LSFIRST

Turns on little endian mode.
When a @code{.WORD} directive is found, it will take the 16 lower significant bits of the value, and from these the least significant byte will be output first to the object file, then the most significant byte.
This is the default.
Use @code{.MSFIRST} to change this behavior.

This example will output the byte @samp{$34} and then @samp{$12} to the output file.

@example
        .LSFIRST
        .WORD $1234
@end example

@node MSFIRST
@subsection MSFIRST

Turns on big endian mode.
When a @code{.WORD} directive is found, it will take the 16 lower significant bits of the value, and from these the most significant byte will be output first to the object file, then the least significant byte.
Use @code{.LSFIRST} to change this behavior.

This example output the byte @samp{$12} and then @samp{$34} to the output file.

@example
        .MSFIRST
        .WORD $1234
@end example

@node NOCODES
@subsection NOCODES

Disables the generation of line numbers, opcodes, etc. in the listing file.
Use @code{.CODES} to enable it again.

@node NOLIST
@subsection NOLIST

Turns off the output to the listing file.
Use @code{.LIST} to enable it again.

@node NOPAGE
@subsection NOPAGE

Accepted but currently ignored.
See the @ref{PAGE} directive as well.

@node ORG
@subsection ORG

@example
[label] .ORG expr
[label] *=expr
[label] $=expr
@end example

Sets the program counter to the value of @code{expr}, which must be in the range @code{[0, 65536]}.
@code{expr} can have references to the current program counter.
For example, to advance the program counter to the next 256 boundary, we can use:

@example
        .ORG ($ + 0FFH) & 0FF00H
@end example

Note that a label that is used with an @code{.ORG} directive will take the value of the program counter set by the @code{.ORG}.

You can use @code{.ORG} or the alternative forms @code{*=} and @code{$=}.

@node PAGE
@subsection PAGE

Accepted but currently ignored.
See the @ref{NOPAGE} directive as well.

@node TEXT
@subsection TEXT

@example
[label] .TEXT string
@end example

Outputs the @code{ASCII} value of each character of the supplied string to the object file as a byte.
Special characters can be embedded in the string using escape sequences.
@xref{String constants}.

@example
msg1    .TEXT "Enter the file name\n"
msg2    .TEXT "Say \"YES\" or \"NO\""
@end example

@c TODO: accepts strings without double quotes?

@node TITLE
@subsection TITLE

Accepted but currently ignored.

@example
        .TITLE "Program version 1.2"
        .TITLE "Subtitle"
@end example

@node WORD
@subsection WORD

@example
[label] .WORD expr [, expr ...]
@end example

The @code{.WORD} directive accepts an expression or a list of expressions, and outputs the 16 bit value of each expression as two bytes.
The default is to output the least significant byte first.
You can change this behavior with the @code{.MSFIRST} and @code{.LSFIRST} directives.

Note that if you use the program counter symbol (@samp{$}) in any expression in a @code{.WORD} directive, it takes the value of the program counter at the beginning of the line, and not its value at the start of each expression.
For example:

@example
START   .EQU  0
        .WORD $1234, $
@end example

will output:

@example
$34 $12 $00
@end example

and not:

@example
$32 $12 $02
@end example

@node Preprocessor directives
@section Preprocessor directives

The preprocessor directives can be used to assemble or not some parts of the source, to include text from other files to assemble, and to define macros that can cause text substitution.

@menu
* DEFINE::	#DEFINE directive.
* DEFCONT::	#DEFCONT directive.
* INCLUDE::	#INCLUDE directive.
* IF::		#IF directive.
* IFDEF::	#IFDEF directive.
* IFNDEF::	#IFNDEF directive.
* ELSE::	#ELSE directive.
* ENDIF::	#ENDIF directive.
@end menu

@node DEFINE
@subsection DEFINE

@example
#DEFINE macro_name[(arg_label [, arg_label ...])] [macro_definition]
@end example

The @code{#DEFINE} directive is used to define a macro name.
Macro names can be used for text substitution.
For example, you can define a label to be expanded to arbitrary text prior compilation:

@example
#DEFINE STARTLO (START & 255)

        .DB STARTLO+1
@end example

When the assembler finds @code{STARTLO}, it will substitute it by the text @code{(START & 255)}, so it will finally assemble this text:

@example
        .DB (START & 255)+1
@end example

The substitution is recursive.
For example:

@example
#DEFINE STARTLO (START & 255)
#DEFINE STARTLO_PLUS_1 (STARTLO+1)

        .DB STARTLO_PLUS_1
@end example

This will expand first to:

@example
        .DB (STARTLO+1)
@end example

And then to:

@example
        .DB ((START & 255)+1)
@end example

Note that you can define a macro label that expands to no text:

@example
#DEFINE VOID

        .DB 5
        VOID
        .DB 6
@end example

And you can make synonyms for directives to, for example, allow to compile the syntax from other assemblers.
For example, imagine an assembler which does not use directives that begin with a dot as we do.
To assemble a source that was written for that assembler with @code{uz80as}, you can use a set of defines at the beginning of your source file, and use them later:

@example
#DEFINE DB .DB
#DEFINE DW .DW

        ...

        DB 5, 6, 7
@end example

You can define macros with arguments, for example:

@example
#DEFINE ADDMAC(x,y) ((x)+(y))

        .DB ADDMAC(5,6)
@end example

This works first by taking the text of the @code{ADDMAC} macro:

@example
((x)+(y))
@end example

and then searches for @code{x} in this text and substitutes it by @code{5}.
Next, finds @code{y} and substitutes it by @code{6}.

@example
((5)+(6))
@end example

Finally, the resulting text is substituted in the original location:

@example
        .DB ((5)+(6))
@end example

Note that if you do not supply a parameter, nothing will be substituted:

@example
        .DB ADDMAC(5)
@end example

will expand into:

@example
        .DB ((5)+(y))
@end example

@c TODO: maximum number of characters per argument.
@c In TASM 16, we have unlimited.

@node DEFCONT
@subsection DEFCONT

@code{#DEFCONT} can be used to add more text to the previous defined macro.
The macro text will always form an unique line, so remember to use the backslash character if you are forming multiline statements:

@example
#DEFINE ADDMAC(x,y)     LD A,x
#DEFCONT                \ LD B,y
#DEFCONT                \ ADD B
@end example

@node INCLUDE
@subsection INCLUDE

@example
#INCLUDE "filename"
@end example

The @code{#INCLUDE} directive is used to include the text of another file
to be assembled.

For example, if the file @samp{common.h} is:

@example
        .DB 5
@end example

and the file @samp{prg.asm} is:

@example
#include "common.h"
        .DB 6
@end example

the assembler will compile

@example
        .DB 5
        .DB 6
@end example

@node IF
@subsection IF

@example
#IF expr
@end example

The @code{#IF} directive evaluates the supplied expression.
If the value of the expression is zero, the next lines are ignored by the assembler, until an @code{#ENDIF} or an @code{#ELSE} directive is found.

If the value of the expression is not zero, the next lines are assembled normally, until an @code{#ENDIF} or @code{#ELSE} directive is found.
In this case, if we find an @code{#ELSE} directive, the next lines after the @code{#ELSE} will be ignored.

In this example, as the expression evaluates to something different than zero, the line @code{LD A,1} will be assembled and @code{LD A,0} ignored:

@example
ASSEMLE .EQU 1

#IF ASSEMBLE
        LD A,1
#ELSE
        LD A,0
#ENDIF
@end example

On the other hand, here the opposite will happen:

@example
ASSEMLE .EQU 1

#IF !ASSEMBLE
        LD A,1
#ELSE
        LD A,0
#ENDIF
@end example

Note that @code{#IF} directives can be nested:

@example
TRUE  .EQU 1
FALSE .EQU 0

#IF TRUE
        #IF FALSE
                LD A,0
        #ELSE
                LD A,1
        #ENDIF
#ELSE
        #IF TRUE
                LD A,2
        #ELSE
                LD A,3
        #ENDIF
#ENDIF
@end example

In this example, this code will be assembled:

@example
        LD A,1
@end example

@node IFDEF
@subsection IFDEF

@example
#IFDEF macro_name
@end example

@code{#IFDEF} is like @code{#IF}, but tests if a macro name has been defined.

@example
#DEFINE SPECTRUM

#IFDEF SPECTRUM
        CALL spectrum_fun
#ELSE
        CALL amstrad_fun
#ENDIF
@end example

will assemble:

@example
        CALL spectrum_fun
@end example

@node IFNDEF
@subsection IFNDEF

@code{#IFNDEF} is like @code{#IFDEF}, but tests if a macro name has not been defined.

@node ELSE
@subsection ELSE

Used to end a section that began with an @code{#IF}, @code{#IFDEF} or @code{IFNDEF} directive.

@node ENDIF
@subsection ENDIF

Used to end a section that began with an @code{#IF}, @code{#IFDEF}, @code{IFNDEF} or @code{#ELSE} directive.

@node Reference
@chapter Reference

@menu
* Invoking uz80as::			How to invoke @command{uz80as}.
* Implementation-defined features::	Features specific to @command{uz80as}.
* Differences with TASM::		How we differ from TASM.
@end menu

@node Invoking uz80as
@section Invoking uz80as

@example
uz80as [OPTION]... ASM_FILE [OBJ_FILE [LST_FILE [EXP_FILE]]]
@end example

Where: 

@table @code
@item ASM_FILE
Source file.
@item OBJ_FILE
Generated file with the compiled machine code.
@item LST_FILE
Generated listing file.
@item EXP_FILE
Generated symbol export file.
@end table

For example, to assemble @file{program.asm} you can use:

@example
uz80as program.asm
@end example

If there are no errors, this will generate the file @file{program.obj} with the binary machine code of the program.
Also, the file @file{program.lst} will be generated with the listing of the source program, plus more info like line numbers, the value of the program counter at each line, the generated machine code in hexadecimal, etc.

Also, if the source program contains any @code{.EXPORT} directive, then the file @file{program.exp} will be generated.

You can give different names for these files by specifying their names after the name of the source file. For example, this will generate the object file with the name @file{program.bin}, the listing file with the name @file{list.txt} and the symbol export file with the name @file{api.asm}:

@example
uz80as program.asm program.bin list.txt api.asm
@end example

If the symbol export file is explicitly given in the command line, then a symbol export file will be generated even if there are no @code{.EXPORT} directives in the source file.

Additional command line options can be used before the these arguments. They are:

@table @code
@item -h, --help
Display usage information and exit.

@item -v, --version
Display version information and exit.

@item -f nn, --fill n
By default, the entire memory addressable (64K) is filled by zero.
You can specify a different value to fill the memory.
@code{'nn'} must be formed by two hexadecimal digits.
For example, to fill the memory with the value 255 decimal, use @code{'-f FF'}.

@item -dmacro, --define macro
Define a macro.
If the macro is simply a label, you can use @code{-dLABEL}.
If it is a macro for text substitution, you have to enclose the macro definition in double quotes. For example: @code{-d"MUL(a,b) (a*b)"}.

@item -q, --quiet
Disables the generation of the listing file.

@item -x, --extended
Accept an alternative syntax for some instructions.

@item -u, --undocumented
Accept undocumented instructions.

@item -t, --target target
Selects the target microprocessor. The default is @code{z80}. See @code{--list-targets} to know the targets accepted.

@item -e, --list-targets
Displays a list of the targets accepted and a brief description.

@item -H, --hex
Outputs an Intel HEX file.

@item -S, --srec
Outputs a Motorola S-Record file.

@end table

@node Implementation-defined features
@section Implementation-defined features

Limits:

@itemize @minus

@item
Maximum number of labels: 15000.
@item
Maximum source line length: 511 characters.
@item
Maximum line length after macro expansion: 511.
@item
Number of significant characters in labels: 31.
@item
Maximum number of nested include files: 127.
@item
Maximum number of macros: 1000.
@item
Maximum number of macro arguments: 10.
@item
Maximum number of nested expressions: 32.

@end itemize

In the places where we can specify an expression, sometimes we require that the labels referenced in the expression have already a well defined value in the first pass of the assembler.
The following directives do not allow to specify a label not already defined at the point where the directive appears in the first pass: @code{#IF}, @code{.BLOCK}, @code{.END}, @code{.EQU}, @code{.FILL} (number of positions), @code{.ORG}.

@node Differences with TASM
@section Differences with TASM

@itemize @minus

@item
@command{uz80as} can generate binary object files, Intel hex files and Motorola S-Record files.

@item
The places in where @command{uz80as} allows for forward references of labels in the first pass of the assembler can differ from @command{TASM}. @xref{Implementation-defined features}.

@item
@command{TASM} always needs a space or a colon @samp{:} character after a label. Anything else is considered an error. So this does not compile in @command{TASM} but it is accepted by @command{uz80as}:

@example
label;comment
LABEL=5
@end example

@item
@command{TASM}, for some reason, ignores the @samp{2} in the following expression and treats it as @samp{*-3}, that is, the current program counter minus 3. We correctly parse it as @samp{2*(-3)}.

@example
        .DB 2*-3
@end example

Something similar happens with the symbol @code{*} used for the current program counter with the multiplication operator.
These:

@example
	.DB ***, **2
@end example

are incorrectly parsed by @command{TASM}.
We correctly parse them as @code{$*$} and @code{$*2}, that is, the current program counter multiplied by itself or by 2.

@item
We allow this while @command{TASM} does not:

@example
        .DB -+1
@end example

@item
@command{TASM} says that it uses logical right shifts (inserting zeros) for the right shift operator, but it is actually using arithmetic right shift (the sign bit is extended) at least on x86 machines. We use arithmetic shift as well. So this results in @code{$FF} in @command{TASM} and @command{uz80as}, instead of @code{$0F} :

@example
	.DB -1>>28
@end example

Moreover, in @command{uz80as} only the least @code{N} bits of the second operand are used in the shifting operation, where @code{N} is the number of bits used by an integer on this machine, minus one.
For a system where an integer is 32 bits, @code{N} is 31.
This seems compatible with @command{TASM}.

@item
We allow the program counter to reach the address 65536 which is outside the address range ([0, 65535]). But if some object is generated after that address, we will issue an error and terminate.

@command{TASM}, on the other hand, shows a strange behavior. For example, this generates an object code of 256 bytes (?) without error:

@example
	.ORG 65536
	.DB 1
	.END
@end example

@command{TASM} accepts this as well without error:

@example
	.ORG -1
	.DB 1
	.END
@end example

@item
We don't accept any negative value to @code{.FILL}.
Starting at @code{.ORG 0}, using @code{.FILL -1} in @command{TASM} generates a 65535 length object file;
@code{.FILL 65536} generates a zero length object file.

In @command{uz80as}, @code{.FILL -1} issues an error;
@code{.FILL 65536} correctly generates a 65536 length object file.

@item
The @code{.MODULE} and @code{.LOCALLABELCHAR} are not accepted at this moment by @command{uz80as}, but they are planned.

@item
It seems that @command{TASM} accepts multiple @code{.END} directives and assembles code after it, at least in binary mode. We don't accept that, but we accept programs without an @code{.END} directive.

@item
We allow to write the instructions @code{ADD}, @code{ADC}, @code{SUB}, @code{SBC}, @code{AND}, @code{OR}, @code{XOR} and @code{CP} with the @code{A} register as the first argument or without it (if the @code{-x} option is specified).
@command{TASM} sticks to the official Zilog syntax. @xref{z80 target}.

@item
@command{TASM} accepts including files without enclosing them in double quotes:

@example
#include file.asm
@end example

We always require the double quotes:

@example
#include "file.asm"
@end example

@end itemize

@node Targets
@chapter Targets

For every instruction accepted for every target:

@itemize @bullet
@item @code{*} marks undocumented instructions (selected with the @code{-u} command line option).
@item @code{e} is an expression. The number of bits actually used of the value depends on the instruction.
@item @code{eN} where N is a number, is an expression but only the N least significant bits are used.
@item @code{bN} where N is a number, is an expression which @emph{must} evaluate to a value representable with N bits.
@item @code{r8} is an expression. The distance from the program counter is calculated and only the least significant byte used.
@end itemize

@menu
* z80 target::			Zilog Z80.
* hd64180 target::		Hitachi HD64180.
* gbcpu target::		Sharp LR35902.
* dp2200 target::		Datapoint 2200 version I.
* dp2200ii target::		Datapoint 2200 version II.
* i4004 target::		Intel 4004.
* i4040 target::		Intel 4040.
* i8008 target::		Intel 8008.
* i8021 target::		Intel 8021.
* i8022 target::		Intel 8022.
* i8041 target::		Intel 8041.
* i8048 target::		Intel 8048.
* i8051 target::		Intel 8051.
* i8080 target::		Intel 8080.
* i8085 target::		Intel 8085.
* mos6502 target::		MOS 6502.
* r6501 target::		Rockwell R6501.
* g65sc02 target::		California Micro Devices G65SC02.
* r65c02 target::		Rockwell R65C02.
* r65c29 target::		Rockewll R65C29.
* w65c02s target::		Western Design Center W65C02S.
* mc6800 target::		Motorola 6800.
* mc6801 target::		Motorola 6801.
* m68hc11 target::		Motorola 68HC11.
* rca1802 target::		RCA 1802.
@end menu

@node z80 target
@section z80 target

The @code{z80} target selects the Zilog Z80 instruction set.
These are the instructions accepted:

@include z80tb.texi

Where:

@itemize @bullet
@item @code{t} is an expression which must evaluate to 0H, 8H, 10H, 18H, 20H, 28H, 30H or 38H.
@item @code{s} is an expression which must evaluate to 0, 1, or 2.
@item For IXi and IYi, this means IX or IY followed by a @code{+} or @code{-} sign and an expression.
@end itemize

@menu
* z80 extended syntax::	 	    Alternative syntax for some instructions.
@end menu

@node z80 extended syntax
@subsection z80 extended syntax

Note that in the official Zilog documentation, some of the arithmetic group of instructions take the @code{A} register as first argument: @code{ADD}, @code{ADC} and @code{SBC}.
Others do not: @code{SUB}, @code{AND}, @code{OR}, @code{XOR} and @code{CP}.
So you write:

@example
	ADD A,B
@end example

and do not write

@example
	ADD B
@end example

And you write:

@example
	SUB B
@end example

but do not write

@example
	SUB A,B
@end example

By default, it is an error to use the unofficial forms of these instructions, but you can enable them by specifying the @code{-x} option at the command line.
With this option enabled, you can write any of these instructions with or without the @code{A} register as the first argument, like this:

@example
	ADD A,B
	ADD B
	SUB A,B
	SUB B
@end example

For compatibility with other assemblers, it is better to keep the official syntax.

@node hd64180 target
@section hd64180 target

The @code{hd64180} target selects the Hitachi HD64180 instruction set.
The instructions accepted are the same as for the @code{z80} target (except undocumented instructions) plus these new instructions:

@include hd64180tb.texi

@menu
* hd64180 extended syntax:: 	    Alternative syntax for some instructions.
@end menu

@node hd64180 extended syntax
@subsection hd64180 extended syntax

@xref{z80 extended syntax}.

@node gbcpu target
@section gbcpu target

The @code{gbcpu} target selects the Sharp LR35902 CPU used in the Nintendo Gameboy.
These are the instructions accepted:

@include gbcputb.texi

Where:

@itemize @bullet
@item @code{s} is an expression which must evaluate to 0H, 8H, 10H, 18H, 20H, 28H, 30H or 38H.
@end itemize

@menu
* gbcpu extended syntax:: 	    Alternative syntax for some instructions.
@end menu

@node gbcpu extended syntax
@subsection gbcpu extended syntax

@xref{z80 extended syntax}.

@node dp2200 target
@section dp2200 target

The @code{dp2200} target selects the Datapoint 2200 version I instruction set.

Important: the Datapoint 2200 version I can only address 8K at maximum but @code{uz80as} at this moment only imposes a 64K limit.

These are the instructions accepted:

@include dp2200tb.texi

@node dp2200ii target
@section dp2200ii target

The @code{dp2200ii} target selects the Datapoint 2200 version II instruction set.

Important: the Datapoint 2200 version II can only address 16K at maximum but @code{uz80as} at this moment only imposes a 64K limit.

The instruction set accepted is the same as for the @code{dp2200} target, plus these new instructions:

@include dp2200iitb.texi

@node i4004 target
@section i4004 target

The @code{i4004} target selects the Intel 4004 instruction set.

Important: the Intel 4004 can only address 4K at maximum but @code{uz80as} at this moment only imposes a 64K limit.

Note that the original Intel syntax was something like this:

@example
LAB,   ISZ 5 255   \ this is a comment
@end example

At this moment, you will need to translate that to a syntax acceptable by @code{uz80as}, for instance:

@example
LAB:   ISZ 5,255   ; this is a comment
@end example

However, we do accept the 0P, 1P, etc. notation to specify a register pair. These are the instructions accepted:

@include i4004tb.texi

Where:

@itemize @bullet
@item @code{p} is an expression which must evaluate to 0,2,4,6,8,10,12 or 14.
@end itemize

@node i4040 target
@section i4040 target

The @code{i4040} target selects the Intel 4040 instruction set.

Important: the Intel 4040 can only address 8K at maximum but @code{uz80as} at this moment only imposes a 64K limit.

The instruction set accepted is the same as for the @code{i4004} target, plus these new instructions:

@include i4040tb.texi

@node i8008 target
@section i8008 target

The @code{i8008} target selects the Intel 8008 instruction set.

Important: the Intel 8008 can only address 16K at maximum but @code{uz80as} at this moment only imposes a 64K limit.

These are the instructions accepted:

@include i8008tb.texi

Where:

@itemize @bullet
@item @code{k} is an expression which must evaluate to a value between 8 and 31.
@end itemize

@node i8021 target
@section i8021 target

The @code{i8021} target selects the Intel 8021 instruction set.

These are the instructions accepted:

@include i8021tb.texi

@node i8022 target
@section i8022 target

The @code{i8022} target selects the Intel 8022 instruction set.
The instruction set accepted is the same as for the @code{i8021} target, plus
these new instrucions:

@include i8022tb.texi

@node i8041 target
@section i8041 target

The @code{i8041} target selects the Intel 8041 instruction set.
The instruction set accepted is the same as for the @code{i8021} target, except that these instructions are removed:

@multitable @columnfractions .25 .25 .25 .25
@item IN A,P0
@tab OUTL P0,A
@end multitable

And these instructions are added:

@include i8041tb.texi

@node i8048 target
@section i8048 target

The @code{i8048} target selects the Intel 8048 instruction set.
The instruction set accepted is the same as for the @code{i8041} target, except that these instructions are removed:

@multitable @columnfractions .25 .25 .25 .25
@item EN FLAGS
@tab EN DMA
@tab IN A,DBB
@tab JNIBF e8
@item JOBF e8
@tab MOV STS,A
@tab OUT DBB,A
@end multitable

And these instructions are added:

@include i8048tb.texi

@node i8051 target
@section i8051 target

The @code{i8051} target selects the Intel 8051 instruction set.

These are the instructions accepted:

@include i8051tb.texi

@node i8080 target
@section i8080 target

The @code{i8080} target selects the Intel 8080.
These are the instructions accepted:

@include i8080tb.texi

@node i8085 target
@section i8085 target

The @code{i8085} target selects the Intel 8085.
The instruction set accepted is the same as for the @code{i8080} target, plus these new instructions:

@include i8085tb.texi

Where:

@itemize @bullet
@item @code{JNX5} and @code{JNUI} are alternative names for the @code{JNK} instruction.
@item @code{JX5}  and @code{JUI} are alternative names for the @code{JK} instruction.
@end itemize

@node mos6502 target
@section mos6502 target

The @code{mos6502} target selects the MOS Technology 6502.
These are the instructions accepted:

@include mos6502tb.texi

Where @code{>} forces the use of a 16 bit address.

@node r6501 target
@section r6501 target

The @code{r6501} target selects the Rockwell R6501.
The instruction set accepted is the same as for the @code{mos6502} target, plus these new instructions:

@include r6501tb.texi

@node g65sc02 target
@section g65sc02 target

The @code{g65sc02} target selects the California Micro Devices G65SC02.
The instruction set accepted is the same as for the @code{mos6502} target, plus these new instructions:

@include g65sc02tb.texi

Where @code{>} forces the use of a 16 bit address.

@node r65c02 target
@section r65c02 target

The @code{r65c02} target selects the Rockwell R65C02.
The instruction set accepted is the same as for the @code{mos6502} target, plus the added instructions of the @code{r6501} and @code{g65sc02} targets.

@node r65c29 target
@section r65c29 target

The @code{r65c29} target selects the Rockwell R65C29, R65C00/21.
The instruction set accepted is the same as for the @code{r65c02} target, plus these new instructions:

@include r65c29tb.texi

@node w65c02s target
@section w65c02s target

The @code{w65c02s} target selects the Western Design Center W65C02S.
The instruction set accepted is the same as for the @code{r65c02} target, plus these new instructions:

@include w65c02stb.texi

@node mc6800 target
@section mc6800 target

The @code{mc6800} target selects the Motorola 6800.
These are the instructions accepted:

@include mc6800tb.texi

Where @code{>} forces the use of a 16 bit address.

@node mc6801 target
@section mc6801 target

The @code{mc6801} target selects the Motorola 6801.
The instruction set accepted is the same as for the @code{mc6800} target, plus these new instructions:

@include mc6801tb.texi

@node m68hc11 target
@section m68hc11 target

The @code{m68hc11} target selects the Motorola 68HC11.
The instruction set accepted is the same as for the @code{mc6801} target, plus these new instructions:

@include m68hc11tb.texi

@node rca1802 target
@section rca1802 target

The @code{rca1802} target selects the RCA 1802.
These are the instructions accepted:

@include rca1802tb.texi

Where:

@itemize @bullet
@item @code{m} is an expression wich must evaluate to a value between 1 and 15.
@item @code{p} is an expression which must evaluate to a value between 1 and 7.
@end itemize

@node Source guide
@chapter Source guide

@menu
* Modules::		Source code as layers of dependencies.
@end menu

@node Modules
@section Modules

@itemize @bullet

@item Layer 0: Base modules
@itemize @minus
@item
@file{utils.c}: generic functions.
@item
@file{ngetopt.c}: command line argument parsing.
@end itemize

@item Layer 1: Including files and error reporting.
@itemize @minus
@item 
@file{err.c}: error reporting functions, error text, memory allocations.
@item
@file{incl.c}: file inclusion stack.
@item
@file{options.c}: program options and file names from the command line.
@end itemize

@item Layer 2: Assembly support.
@itemize @minus
@item
@file{sym.c}: symbol table (table of labels and values).
@item
@file{expr.c}: expression parsing.
@item
@file{pp.c}: preprocessor, macro table.
@item
@file{list.c}: listing generation.
@item
@file{ihex.c}: outout generation for Intel HEX.
@item
@file{srec.c}: output generation for Motorola S-Record.
@end itemize

@item Layer 3: Assembler
@itemize @minus
@item
@file{uz80as.c}: the assembler program.
@item
@file{target/*.c}: the different targets.
@item
@file{targets.c}: enumeration of the different targets available.
@item
@file{prtable.c}: to print the instruction sets of the targets.
@item
@file{main.c}: the entry point.
@end itemize

@end itemize

@node Copyright
@chapter Copyright
@insertcopying

@bye
